# Asm

> [GitHub Classroom - TBD](https://github.com)  

## Задание
По [адресу](http://github.com/sorokin/cpp-course) лежит пример двух программ на ассемблере:
* Программа `hello.asm` — это программа выводящая строку "Hello, world". В ней подробно прокомментирована каждая строчка.
* Программа `add.asm` — это программа, которая выполняет сложение двух длинных чисел.

Вам необходимо разобраться в этих примерах и написать на их основе программы выполняющие вычитание и умножение беззнаковых длинных чисел.

Обратите внимание, что приведенные примеры заточены на конкретную архитектуру процессора (x86-64), конкретный ассемблер (NASM) и операционную систему (Linux).

Разрешается писать программы под другие архитектуры, ассемблеры и операционные системы, при этом вам придется самим переписать код на нужную архитектуру и разобраться как сделать ввод-вывод. Если вы будете делать программу под архитектуру отличную от x86_64 или i386, предварительно согласуйте это со мной.

## Запуск примеров
Для того, чтобы запустить примеры на понадобится любой 64-битный дистрибутив Linux. Чтобы проверить битность вашего дистрибутива, можно исполнить команду:
```console
$ uname -m
```

Если команда выводит x86_64, то система 64-битная, если i386 или i686 — 32-битная.

Для работы нам потребуются следующие инструменты:

* NASM — собственно сам ассемблер
* GNU Binutils — пакет программ для работы с бинарными файлами от проекта GNU (нам из них понадобится только ld)
* GCC — коллекция компиляторов проекта GNU (нам из них понадобится только драйвер gcc)
* GDB — отладчик
* Qt Creator — IDE
* CMake — система сборки
* Git — система контроля версий
* Чтобы установить эти программы (в Debian-based дистрибутивах) необходимо исполнить команду:

```console
$ sudo apt-get install nasm binutils gcc gdb qtcreator cmake git
```

Чтобы взять исходный код примеров необходимо исполнить команду:

```console
$ git clone https://github.com/sorokin/cpp-course.git
```
После этого в текущем каталоге появится каталог cpp-course. Заходим внутрь:

```console
$ cd cpp-course/helloasm
```
Проверяем, что всё компилируется:

```console
$ cmake .
$ make
```
В текущем каталоге должны появится файлы hello и add. Проверяем, что всё работает:

```console
$ ./hello
Hello, world!
$ ./add
10000000000000000000000000000000000000
100000000000000000000000000000000000000000000000000000000000000
100000000000000000000000010000000000000000000000000000000000000
```
Чтобы редактировать код в IDE, необходимо запустить Qt Creator:

```console
$ qtcreator
```
И попытаться открыть файл helloasm/CMakeLists.txt.

## Возможные проблемы

Поскольку мы не создаем корректных стековых фреймов и не генерим dwarf-символов для отладки, то отладчик не может корректно показать стек вызовов (видно на скриншоте), по этой же причине иногда не работает Step Over (F10).
* Решение 1: Можно создавать стековый фрейм руками, но это придется делать в каждой функции.
* Решение 2: Можно использовать CFI-директивы для указания того, как нужно раскручивать стек, но NASM их не поддерживает, поэтому в качестве ассемблера придется использовать GNU as.

Нажатие Step Into (F11)/Step Over(F10), когда программа не запущена приводит к тому, что программа запускается и отрабатывает до выхода, вместо того, чтобы остановиться на первой строчке. Дело в том, что QtCreator ставит breakpoint на main и запускает программу, чтобы она брейкнулась в main. Но поскольку в наших программа функции main нет, программа просто отрабатывает до конца.
* Решение 1: Поставить breakpoint в начале программы.
* Решение 2: Создать метку main. Её можно добавить там же, где и _start:
```asm
                global          _start
                global          main
_start:      
main:
```
